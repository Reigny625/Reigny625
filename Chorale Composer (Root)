package mainPackage;
import java.util.Arrays;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import javax.sound.midi.*;

@SuppressWarnings({"unused"})
public class Main {
	
	private static final List<String> NOTEEQUIVALENCIES = Arrays.asList("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B");
	private static MidiChannel[] channels;
	private static final int INSTRUMENT = 0; // 0 is a piano, 9 is percussion
	private static int volume;
	private static int tempo;
	private static int noteValueLength;	//tempo in milliseconds (not to be tampered with)
	private static int key;
	private static boolean isMajor;
	private static int[] chordProgression;
	private static String[][] voicedChords;
	

	public static void main(String[] args){
		try {
			
			//initializes the synth
			Synthesizer synth = MidiSystem.getSynthesizer();
			synth.open();
			channels = synth.getChannels();
			
			
			/*	Rhythmic testing
			int minNoteValue = 256;
			int num = (int)(Math.log(minNoteValue/4) / Math.log(2));
			for(int i = 0; i <= num; i++) {
				for(int j = 0; j < Math.pow(2, i); j++) {
					playNote(Double.toString(Math.random()*6+2) + "C", 1.0/Math.pow(2, i));
				}
			}
			*/
			initStaff();
			
			setChordProgression();
			
			voiceChords();
			
			System.out.println(Arrays.toString(chordProgression));
			for(int chordNumeral: chordProgression) {
				System.out.print(chordToTone(chordNumeral, 1) + " ");
			}
			System.out.println();
			for(int i = 0; i < voicedChords.length; i++) {
				System.out.print(Arrays.toString(voicedChords[i]));
				System.out.print("   ");
			}
			
			//For testing purposes only. Delete voicedChords is consistently fully defined
			for(int i = 0; i < 4; i++) {
				playNotes(voicedChords[i][0] + ", " + voicedChords[i][1] + ", " + voicedChords[i][2] + ", " + voicedChords[i][3], 1.3);
			}
			rest(1);
			
			//playChords(1.3);
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private static void playChords(int beatsPerChords) {
		try {
			for(int i = 0; i < voicedChords.length; i++) {
				playNotes(voicedChords[i][0] + ", " + voicedChords[i][1] + ", " + voicedChords[i][2] + ", " + voicedChords[i][3], beatsPerChords);
			}
			rest(1);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private static void voiceChords() {
		voicedChords = new String[chordProgression.length][4];
		
		//1st Chord
		ArrayList<Integer> remainingTones = new ArrayList<Integer>();
		remainingTones.add(1);
		remainingTones.add(3);
		remainingTones.add(5);
		Collections.shuffle(remainingTones);
		
		voicedChords[0][0] = "3" + chordToTone(chordProgression[0], 1);
		
		for(int i = 1; i <= 3; i++) {
			int octave = 8;
			voicedChords[0][i] = Integer.toString(octave) + chordToTone(chordProgression[0], remainingTones.get(0));
			while(id(voicedChords[0][i]) - id(voicedChords[0][i-1]) > 12) {
				octave--;
				voicedChords[0][i] = Integer.toString(octave) + voicedChords[0][i].substring(1);
			}
			remainingTones.remove(0);
		}
		
		//All the other chords
		//for(int i = 1; i < chordProgression.length; i++) {	//loops through all non-bass voices of the chord under construction
		for (int i = 1; i < 4; i++) { //TEMPORARY LINE. Replace with above when ready
			remainingTones = new ArrayList<Integer>();
			remainingTones.add(1);
			remainingTones.add(3);
			remainingTones.add(5);
			
			if(chordProgression[i-1] == chordProgression[i]) {	//identifies if it's a repeated chord
				//TO DO HEREHERE TO DO
			} else if(true) {	//TO DO HEREHERE TO DO: Replace with if(Distance between roots is a 4th/5th or 3rd/6th)
				//Copies all common tones
				for(int j = 1; j <= 3; j++) {	//loops through all non-bass voices of the previous chord
					for(int k = 0; k < remainingTones.size(); k++) {	//loops through all remaining chord tones
						if(voicedChords[i-1][j].substring(1).equals(chordToTone(chordProgression[i], remainingTones.get(k)))){
							voicedChords[i][j] = voicedChords[i-1][j];
							remainingTones.remove(k);
							k = remainingTones.size();	//exits the innermost loop (or rather, makes this execution of the loop the final one)
						}
					}
				}
				
				//Places stepwise tones accordingly
				while(remainingTones.size() > 0) {
					for(int j = 1; j <= 3; j++) {	//loops through all non-bass voices of the chord under construction
						if(voicedChords[i][j] == null) {
							int conjunctPossibilities = 0;
							int possibleConjunctCToneIndex = -1;
							
							for(int k = 0; k < remainingTones.size(); k++) {
								String previousNote = voicedChords[i-1][j].substring(1);
								String possibleTargetNote = chordToTone(chordProgression[i], remainingTones.get(k));
								if( Math.abs(id("4" + previousNote) - id("4" + possibleTargetNote)) < 3 ||
									Math.abs(id("3" + previousNote) - id("4" + possibleTargetNote)) < 3 ||
									Math.abs(id("4" + previousNote) - id("3" + possibleTargetNote)) < 3 ) {
									
									conjunctPossibilities++;
									possibleConjunctCToneIndex = k;
								}
							}
							
							if(conjunctPossibilities == 1) {
								voicedChords[i][j] = chordToTone(chordProgression[i], remainingTones.get(possibleConjunctCToneIndex));
								remainingTones.remove(possibleConjunctCToneIndex);
							}
						}
					}
				}
				
				//Gives octaves to the non-bass voices
				for(int j = 1; j < 4; j++) {
					if(!Character.isDigit(voicedChords[i][j].charAt(0))) {
						if((int)voicedChords[i][j].charAt(0) >= 68 || voicedChords[i][j].charAt(0) == 'A') {
							voicedChords[i][j] = voicedChords[i-1][j].charAt(0) + voicedChords[i][j];
						} else {
							switch (voicedChords[i-1][j].substring(1)) {
							case "C":
							case "C#":
								if(voicedChords[i][j].equals("B") || voicedChords[i][j].equals("A#")) {
									voicedChords[i][j] = "" + (Character.getNumericValue(voicedChords[i-1][j].charAt(0)) - 1) + voicedChords[i][j];
								}
								break;
							case "B":
							case "A#":
								if(voicedChords[i][j].equals("C") || voicedChords[i][j].equals("C#")) {
									voicedChords[i][j] = "" + (Character.getNumericValue(voicedChords[i-1][j].charAt(0)) + 1) + voicedChords[i][j];
								}
								break;
							}
						}
					}
				}
				
				//Adds the bass voice below tenor
				int octave = Character.getNumericValue(voicedChords[i][3].charAt(0)) + 1;
				voicedChords[i][0] = chordToTone(chordProgression[i], 1);
				voicedChords[i][0] = "" + octave + voicedChords[i][0];
				while(id(voicedChords[i][0]) >= id(voicedChords[i][1])) {
					octave--;
					voicedChords[i][0] = "" + octave + voicedChords[i][0].substring(1);
				}
				
			} else if(true) {	//TO DO HEREHERE TO DO: Replace with if(Distance between roots is a 2nd/7th)
				System.out.println("Got the the 2nds/7ths statement, Oh No!");
			}
			
		}
		
	}
	
	private static String chordToTone(int chord, int toneNum) {
		if(isMajor) {
			String[] majorScale = new String[] {"C", "D", "E", "F", "G", "A", "B"};
			return majorScale[( (chord-1) + (toneNum-1) ) % 7];
		} else {
			String[] minorScale = new String[] {"C", "D", "Eb", "F", "G", "Ab", "B"};
			String out = minorScale[( (chord-1) + (toneNum-1) ) % 7];
			if(chord == 3 && toneNum == 5) {
				out = "Bb";
			}
			return out;
		}
	}
	
	private static void setChordProgression() {
		//chordProgression = new int[8];
		chordProgression = new int[] {1, 5, 1, 4, 3, 1, 1, 5};
		//Set to randomized chord progression based on the table?
	}
	
	private static void initStaff() {
		volume = 40; // between 0 and 127 inclusive
		tempo = 60;	//tempo in bpm
		updateTempo();
		key = (int)(Math.random()*12);
		isMajor = Math.random()<0.5;
	}
	
	private static void updateTempo() {
		noteValueLength = 60000/(tempo);
	}
	
	private static void playNotes(String noteList, double duration) throws InterruptedException{
		String[] notes = noteList.replaceAll(" ", "").replaceAll("Db", "C#").replaceAll("Eb", "D#").replaceAll("Gb", "F#").replaceAll("Ab", "G#").replaceAll("Ab", "B#").split(",");
		
		// * start playing a note
		for(String note: notes) {
			channels[INSTRUMENT].noteOn(id(note), volume);
		}
		
		// * wait
		rest(duration);
		// * stop playing a note
		for(String note: notes) {
			channels[INSTRUMENT].noteOff(id(note));
		}
	}
	
	/**
	 * Plays nothing for the given duration
	 */
	private static void rest(double duration) throws InterruptedException
	{
		TimeUnit.MILLISECONDS.sleep((long)(duration*noteValueLength));
	}
	
	/**
	 * Returns the MIDI id for a given note: eg. 4C -> 60
	 */
	private static int id(String note)
	{
		int octave = Integer.parseInt(note.substring(0, 1));
		if(note.length() > 2 && note.charAt(2) == 'b') {	//If it's a flat, then this turns it into the enharmonic sharp
			note = noteName(id(note.substring(0, 2)) - 1);
		}
		return NOTEEQUIVALENCIES.indexOf(note.substring(1)) + (12 * octave) + 12;	
	}
	
	private static String noteName(int id) {
		int octave = (id / 12) - 1;
		return octave + NOTEEQUIVALENCIES.get(id % 12);
	}
	
}
